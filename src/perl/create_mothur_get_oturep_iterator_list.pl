#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
BEGIN{foreach (@INC) {s/\/usr\/local\/packages/\/local\/platform/}};
use lib (@INC,$ENV{"PERL_MOD_DIR"});
no lib "$ENV{PERL_MOD_DIR}/i686-linux";
no lib ".";

=head1 NAME

create_mothur_get_oturep_iterator_list.pl - Default output is a workflow iterator that can be used to iterator over input for cluster

=head1 SYNOPSIS

USAGE: ./create_mothur_get_oturep_iterator_list.pl --distance_file=/path/to/distance/file --fasta_file_list=/path/to/distance/file
                                                   --names_file_list=/path/to/name/files/list --list_file_list=/path/to/list/files/list
                                                   --output=/path/to/output/iterator
                                               
=head1 OPTIONS

B<--list_file, -i>
    A single list of sequence names that are complementary to the distance matrix.

B<--list_file_list, il>
    A list of list of sequence names that are complementary to the distance matrix.

B<--fasta_file_list, -s>
    A list of sequence files in FASTA format

B<--distance_file_list, -dl>
    A list of sequence files in FASTA format.    

B<--names_file_list, -n>
    A list of mothur unique.seqs generated name files.
       
B<--output, -o>
    Desired path to output iterator file
    
B<--log, -l>
    Optional. Log file.
    
B<--debug, -d>
    Optional. Debug level.
    
B<--help>
    Print perldocs for this script.
    
=head1 DESCRIPTION

Creates an ergatis/workflow iterator list file for a distributed mothur get.oturep job. The iterator contains all the parameters needed to run 
unique.seqs successfully, attempting to pair up groups of files (distance file - fasta file - list file) based of the base filename prefix
(e.x. AMP01_LUNG.trim.dist - AMP01_LUNG.trim.names would be grouped together as they all carry the AMP01_LUNG prefix).

=head1 INPUT

The mandatory input files are the distance file, fasta file and list file. Optionanlly a names file generated by trim.seqs can also be included.
                    
=head1 OUTPUT

An ergatis iterator list.

=head1 CONTACT

    Cesar Arze
    carze@som.umaryland.edu
    
=cut

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use Pod::Usage;
use File::Basename;
use Ergatis::Logger;
umask(0000);
my $logger;


my %options = &parse_options();
my $list_file = $options{'list_file'};
my $list_file_list = $options{'list_file_list'};
my $fasta_files = $options{'fasta_file_list'};
my $distance_file = $options{'distance_file_list'};
my $group_file = $options{'group_file_list'};
my $names_list = $options{'names_file_list'};
my $output = $options{'output'};

# Mandatory input...
my @list_files = &parse_list_files($list_file, $list_file_list);
my $fasta_list = &parse_list_file($fasta_files);
my $distance_files = &parse_list_file($distance_file);
my $group_files = &parse_list_file($group_file);

# Optional input
my $name_files = parse_list_file($names_list) if defined ($options{'names_file_list'});

open (OUTFILE, "> $output") or $logger->logdie("Could not open output iterator $output for writing: $!");
print OUTFILE '$;I_FILE_BASE$;' . "\t" .
              '$;I_FILE_NAME$;' . "\t" .
              '$;I_FILE_PATH$;' . "\t" .
              '$;FASTA_FILE$;' . "\t" .
              '$;DISTANCE_FILE$;' . "\t" .
              '$;GROUP_FILE$;' . "\t" .
              '$;NAME_FILE$;' . "\n";
                            
# Iterate over all distance files and if a corresponding name file exists print it out
# to the iterator list as well.                            
foreach my $list (@list_files) {
    my $filename = basename($list);
    my $file_base = fileparse($list, '\.(.*)');
    my $fasta = $fasta_list->{$file_base};
    my $distance = $distance_files->{$file_base};
    my $name = $name_files->{$file_base};
    my $group = $group_files->{$file_base};

    print OUTFILE "$file_base\t$filename\t$list\t$fasta\t$distance\t$group\t$name\n";    
}              

close OUTFILE;
              
#########################################################################
#                                                                       #
#                           SUBROUTINES                                 #
#                                                                       #
#########################################################################

## Parses a list file, creating a hash containing file prefix as key and 
## absolute filename as value.
sub parse_list_file {
    my $file = shift;
    my $files = ();
    
    open (FILELIST, $file) or $logger->logdie("Could not open list $file: $!");
    while (my $line = <FILELIST>) {
        chomp ($line);
        my $file_prefix = fileparse($line, '\.(.*)');
        
        if ( &verify_file($line) && !( exists($files->{$file_prefix}) ) ) {
            $files->{$file_prefix} = $line;
        } else {
            $logger->logwarn("Duplicate file prefix found for file $line");
        }
    }
    
    close (FILELIST);   
    return $files;
}
                 
# Parses list of distance files returning an array containing absolute
# paths to each distance file.                 
sub parse_list_files {
    my ($list_file, $list_file_list) = @_;
    my @files;
    
    ## Handle a single distance file being passed in...
    push (@files, $list_file) if ( defined($list_file) && &verify_file($list_file) );
    if ( defined($list_file_list) && &verify_file($list_file_list) ) {
        open (INLIST, $list_file_list) or $logger->logdie("Could not open list file list $list_file_list: $!");
        
        while (my $line = <INLIST>) {
            chomp ($line);
            push (@files, $line) if ( &verify_file($line) );
        }
        
        close (INLIST);
    }
    
    $logger->logdie("No list files found in input provided.") if (scalar @files == 0);
    return @files;
}                 

# Verifies that a file exists, is readable and is not zero-content.
sub verify_file {
    my @files = @_;
    
    foreach my $file (@files) {
        next if ( (-e $file) && (-r $file) && (-s $file) );
        
        if      (!-e $file) { $logger->logdie("File $file does not exist")   }
        elsif   (!-r $file) { $logger->logdie("File $file is not readable")  }
        elsif   (!-s $file) { $logger->logdie("File $file has zero content") }
    }
    
    return 1;
}
                    
sub parse_options {
    my %opts = ();
    
    GetOptions(\%opts,
                'list_file|i=s',
                'list_file_list|il=s',
                'fasta_file_list|s=s',
                'distance_file_list|lf=s',
                'names_file_list|n=s',
                'group_file_list|g=s',
                'output|o=s',
                'log|l=s',
                'debug|d=s',
                'help') || pod2usage();
       
    if ($opts{'help'}) {
        pod2usage ( { -exitval => 0, -verbose => 2, -output => \*STDERR } );
    }
    
    ## Initialize and configure logging...
    my $logfile = $opts{'log'} || Ergatis::Logger::get_default_filename();
    my $debug = $opts{'debug'} ||= 4;
    $logger = new Ergatis::Logger( 'LOG_FILE'   =>  $logfile,
                                   'LOG_LEVEL'  =>  $debug );
    $logger = Ergatis::Logger::get_logger();
   
    ## Check to make sure certain parameters are defined...
    defined ($opts{'output'}) || $logger->logdie("Please specify an output iterator file.");
    defined ($opts{'fasta_file_list'}) || $logger->logdie("Please specify a list of FASTA files.");
    defined ($opts{'distance_file_list'}) || $logger->logdie("A list of distance files (phylip or column format) is required..");
    defined ($opts{'group_file_list'}) || $logger->logdie("Please specify a groups list.");

    ( ( defined ($opts{'list_file'}) ) || ( defined ($opts{'list_file_list'}) ) ) || $logger->logdie("A single list file or list of list files is required.");
    
    return %opts;                
}                                                                                        
