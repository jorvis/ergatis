#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
BEGIN{foreach (@INC) {s/\/usr\/local\/packages/\/local\/platform/}};
use lib (@INC,$ENV{"PERL_MOD_DIR"});
no lib "$ENV{PERL_MOD_DIR}/i686-linux";
no lib ".";

=head1 NAME

create_mothur_screen_seqs_iterator_list.pl - Default output is a workflow iterator that can be used to iterator over input for screen.seqs

=head1 SYNOPSIS

USAGE: ./create_mothur_screen_seqs_iterator_list.pl --alignment_file_list=/path/to/mothur/align/seqs/output --names_file_list=/path/to/name/files/list
                                               --groups_file_list=/path/to/name/groups/list --align_report_file_list=/path/to/align/report/file/list
                                               --output=/path/to/output/iterator
                                               
=head1 OPTIONS

B<--alignment_file_list, -a>
    A list of mothur align.seqs generated alignment files.

B<--names_file_list, -n>
    A list of mothur unique.seqs generated name files.
    
B<--groups_file_list, -g> 
    A list of mothur trim.seqs generated group files.
    
B<--align_report_file_list, -r>
    A list of mothur align.seqs generated align report files.
    
B<--output, -o>
    Desired path to output iterator file
    
B<--log, -l>
    Optional. Log file.
    
B<--debug, -d>
    Optional. Debug level.
    
B<--help>
    Print perldocs for this script.
    
=head1 DESCRIPTION

Creates an ergatis/workflow iterator list file for a distributed mothur screen.seqs job. The iterator contains all the parameters needed to run 
screen.seqs successfully, attempting to pair up groups of files (alignment file - name file - group file - align report file) based of the base filename prefix
(e.x. AMP01_LUNG.trim.unique.align - AMP01_LUNG.trim.names - AMP01_LUNG.trim.unique.group would be grouped together as they all carry the AMP01_LUNG prefix).

=head1 INPUT

The only mandatory input file is the alignment file generated by align.seqs. Three optional files can be provided

                    1.) name file
                    2.) group file
                    3.) align report file
                    
=head1 OUTPUT

An ergatis iterator list.

=head1 CONTACT

    Cesar Arze
    carze@som.umaryland.edu
    
=cut

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use Pod::Usage;
use File::Basename;
use Ergatis::Logger;
umask(0000);

my $logger;

my %options = &parse_options();
my $align_file = $options{'align_file'};
my $align_list = $options{'alignment_file_list'};
my $names_list = $options{'names_file_list'};
my $groups_list = $options{'groups_file_list'};
my $report_list = $options{'align_report_file_list'};
my $output = $options{'output'};


my @alignment_files = parse_alignment_files($align_file, $align_list);
my $name_files = parse_list_file($names_list) if defined ($options{'names_file_list'});
my $group_files = parse_list_file($groups_list) if defined ($options{'names_file_list'});
my $report_files = parse_list_file($report_list) if defined ($options{'align_report_file_list'});

open (OUTFILE, "> $output") or $logger->logdie("Could not open output iterator $output for writing: $!");
print OUTFILE '$;I_FILE_BASE$;' . "\t" .
              '$;I_FILE_NAME$;' . "\t" .
              '$;I_FILE_PATH$;' . "\t" .
              '$;NAME_FILE$;' . "\t" .
              '$;GROUP_FILE$;' . "\t" .
              '$;REPORT_FILE$;' . "\n";
              
foreach my $align (@alignment_files) {
    my $filename = basename($align);
    my $file_base = fileparse($align, '\.(.*)');
    my $name = $name_files->{$file_base};
    my $group = $group_files->{$file_base};
    my $report = $report_files->{$file_base};
    
    print OUTFILE "$file_base\t$filename\t$align\t$name\t$group\t$report\n";    
}              

close OUTFILE;
              
#########################################################################
#                                                                       #
#                           SUBROUTINES                                 #
#                                                                       #
#########################################################################

## Parses a list file, creating a hash containing file prefix as key and 
## absolute filename as value.
sub parse_list_file {
    my $file = shift;
    my $files = ();
    
    open (FILELIST, $file) or $logger->logdie("Could not open list $file: $!");
    while (my $line = <FILELIST>) {
        chomp ($line);
        my $file_prefix = fileparse($line, '\.(.*)');
        
        if ( &verify_file($line) && !( exists($files->{$file_prefix}) ) ) {
            $files->{$file_prefix} = $line;
        } else {
            $logger->logwarn("Duplicate file prefix found for file $line");
        }
    }
    
    close (FILELIST);   
    return $files;
}
 
## Parse all our alignment files and return an array containing all verified files                
sub parse_alignment_files {
    my ($align_file, $align_list) = @_;
    my @files;
    
    ## Handle a single alignment file being passed in...
    push (@files, $align_file) if ( defined($align_file) && &verify_file($align_file) );
    if ( &verify_file($align_list) ) {
        open (ALIGNLIST, $align_list) or $logger->logdie("Could not open alignment file list $align_list: $!");
        
        while (my $line = <ALIGNLIST>) {
            chomp ($line);
            push (@files, $line) if ( &verify_file($line) );
        }
        
        close (ALIGNLIST);
    }
    
    $logger->logdie("No alignment files found in input provided.") if (scalar @files == 0);
    return @files;
}                 

## Verify a file to make sure it exists, is readable and is not zero-content.
sub verify_file {
    my @files = @_;
    
    foreach my $file (@files) {
        next if ( (-e $file) && (-r $file) && (-s $file) );
        
        if      (!-e $file) { $logger->logdie("File $file does not exist")   }
        elsif   (!-r $file) { $logger->logdie("File $file is not readable")  }
        elsif   (!-s $file) { $logger->logdie("File $file has zero content") }
    }
    
    return 1;
}
                    
sub parse_options {
    my %opts = ();
    
    GetOptions(\%opts,
                'align_file|i=s',
                'alignment_file_list|a=s',
                'names_file_list|n=s',
                'groups_file_list|g=s',
                'align_report_file_list|r=s',
                'output|o=s',
                'log|l=s',
                'debug|d=s',
                'help') || pod2usage();
       
    if ($opts{'help'}) {
        pod2usage ( { -exitval => 0, -verbose => 2, -output => \*STDERR } );
    }
    
    ## Initialize and configure logging...
    my $logfile = $opts{'log'} || Ergatis::Logger::get_default_filename();
    my $debug = $opts{'debug'} ||= 4;
    $logger = new Ergatis::Logger( 'LOG_FILE'   =>  $logfile,
                                   'LOG_LEVEL'  =>  $debug );
    $logger = Ergatis::Logger::get_logger();
   
    ## Check to make sure certain parameters are defined...
    defined ($opts{'alignment_file_list'}) || $logger->logdie("Please specify a valid alignment file list.");
    defined ($opts{'output'}) || $logger->logdie("Please specify an output iterator file.");
                       
    return %opts;                
}                                                                                        
